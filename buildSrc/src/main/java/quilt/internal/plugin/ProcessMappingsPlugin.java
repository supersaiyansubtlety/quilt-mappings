package quilt.internal.plugin;

import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.file.Directory;
import org.gradle.api.plugins.JavaPlugin;
import org.gradle.api.plugins.PluginContainer;
import org.gradle.api.tasks.TaskContainer;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.api.tasks.javadoc.Javadoc;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import quilt.internal.Constants;
import quilt.internal.decompile.javadoc.MappingsJavadocProvider;
import quilt.internal.tasks.build.AddProposedMappingsTask;
import quilt.internal.tasks.build.EraseByteCodeTask;
import quilt.internal.tasks.build.GenFakeSourceTask;
import quilt.internal.tasks.build.MergeTinyV2Task;
import quilt.internal.tasks.decompile.DecompileVineflowerTask;
import quilt.internal.tasks.jarmapping.MapNamedJarTask;
import quilt.internal.tasks.setup.DownloadMinecraftLibrariesTask;
import quilt.internal.tasks.setup.JavadocJarTask;
import quilt.internal.tasks.setup.SourcesJarTask;

public abstract class ProcessMappingsPlugin implements MappingsProjectPlugin {
    public static final String JAVADOC_CLASSPATH_CONFIGURATION_NAME = "javadocClasspath";

    @Nullable
    private Tasks tasks;

    public Tasks getTasks() {
        return this.requireNonNullTasks(this.tasks);
    }

    @Override
    public void apply(@NotNull Project project) {
        final Configuration javadocClasspath = project.getConfigurations().create(JAVADOC_CLASSPATH_CONFIGURATION_NAME);

        // apply required plugins and save their registered objects
        final PluginContainer plugins = project.getPlugins();

        // adds javadoc task
        plugins.apply(JavaPlugin.class);

        final MinecraftJarsPlugin.Tasks minecraftJarsTasks =
            plugins.apply(MinecraftJarsPlugin.class).getTasks();
        final TaskProvider<DownloadMinecraftLibrariesTask> downloadMinecraftLibraries =
            minecraftJarsTasks.downloadMinecraftLibraries();

        final MapMinecraftJarsPlugin.Tasks mapMinecraftJarsTasks =
            plugins.apply(MapMinecraftJarsPlugin.class).getTasks();
        final TaskProvider<AddProposedMappingsTask> insertAutoGeneratedMappings =
            mapMinecraftJarsTasks.insertAutoGeneratedMappings();

        final MapV2Plugin.Tasks mappingsV2Tasks =
            plugins.apply(MapV2Plugin.class).getTasks();
        final TaskProvider<MergeTinyV2Task> mergeTinyV2 =
            mappingsV2Tasks.mergeTinyV2();
        final var mapNamedJar =
            mappingsV2Tasks.mapNamedJar();

        // register this plugin's tasks
        final TaskContainer tasks = project.getTasks();

        final var eraseBytecode = tasks.register(
            EraseByteCodeTask.ERASE_BYTECODE_TASK_NAME,
            EraseByteCodeTask.class,
            task -> {
                task.getJarFile().convention(mapNamedJar.flatMap(MapNamedJarTask::getOutputJar));

                task.getOutput().convention(this.getTempDir().map(dir -> dir.dir("erased-classes")));
            }
        );

        final var genFakeSource = tasks.register(
            GenFakeSourceTask.GEN_FAKE_SOURCE_TASK_NAME,
            GenFakeSourceTask.class,
            task -> {
                task.getSources().from(eraseBytecode.flatMap(EraseByteCodeTask::getOutput));

                task.getLibraries().from(
                    downloadMinecraftLibraries.flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                );

                task.getDefaultJavadocSource().convention(
                    MappingsJavadocProvider.provideNamed(mergeTinyV2.flatMap(MergeTinyV2Task::getOutputMappings))
                );

                task.getOutput().convention(this.getTempDir().map(dir -> dir.dir("fakeSource")));
            }
        );

        final var decompileVineflower = tasks.register(
            DecompileVineflowerTask.DECOMPILE_VINEFLOWER_TASK_NAME,
            DecompileVineflowerTask.class,
            task -> {
                task.getSources().from(mapNamedJar.flatMap(MapNamedJarTask::getOutputJar));

                task.getLibraries().from(
                    downloadMinecraftLibraries.flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                );

                task.getDefaultJavadocSource().convention(MappingsJavadocProvider.provideNamed(
                    insertAutoGeneratedMappings.flatMap(AddProposedMappingsTask::getOutputMappings)
                ));

                // TODO move this to build/ once generate-diff.yml uses generateDiff
                task.getOutput().convention(this.getProjectDir().dir("namedSrc"));
            }
        );

        // sources are added in build.gradle because they're from a project source set
        tasks.register(SourcesJarTask.SOURCES_JAR_TASK_NAME, SourcesJarTask.class);

        final var javadoc = tasks.named(JavaPlugin.JAVADOC_TASK_NAME, Javadoc.class, task -> {
            task.setGroup(Constants.Groups.JAVADOC_GENERATION);

            task.source(genFakeSource.flatMap(GenFakeSourceTask::getOutput).map(Directory::getAsFileTree));

            task.setClasspath(
                this.getProjectDir().files(
                    javadocClasspath,
                    downloadMinecraftLibraries
                        .flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                        .map(Directory::getAsFileTree),
                    mapNamedJar.flatMap(MapNamedJarTask::getOutputJar)
                )
            );
        });

        tasks.register(JavadocJarTask.JAVADOC_JAR_TASK_NAME, JavadocJarTask.class, task -> {
            task.from(javadoc.map(Javadoc::getDestinationDir));
        });

        this.tasks = new Tasks(decompileVineflower);
    }

    public record Tasks(TaskProvider<DecompileVineflowerTask> decompileVineflower) { }
}
