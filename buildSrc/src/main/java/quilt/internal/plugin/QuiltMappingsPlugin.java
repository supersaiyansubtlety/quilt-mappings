package quilt.internal.plugin;

import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.file.Directory;
import org.gradle.api.file.DirectoryProperty;
import org.gradle.api.model.ObjectFactory;
import org.gradle.api.plugins.PluginContainer;
import org.gradle.api.provider.Provider;
import org.gradle.api.provider.ProviderFactory;
import org.gradle.api.tasks.TaskContainer;
import org.gradle.api.tasks.TaskProvider;
import org.jetbrains.annotations.NotNull;
import quilt.internal.Constants;
import quilt.internal.QuiltMappingsExtension;
import quilt.internal.tasks.build.MappingsV2JarTask;
import quilt.internal.tasks.decompile.DecompileVineflowerTask;
import quilt.internal.tasks.diff.DecompileTargetVineflowerTask;
import quilt.internal.tasks.diff.DownloadTargetMappingJarTask;
import quilt.internal.tasks.diff.DownloadTargetMetaFileTask;
import quilt.internal.tasks.diff.ExtractTargetMappingJarTask;
import quilt.internal.tasks.diff.DiffDirectoriesTask;
import quilt.internal.tasks.diff.RemapTargetMinecraftJarTask;
import quilt.internal.tasks.diff.RemapTargetUnpickDefinitionsTask;
import quilt.internal.tasks.diff.TargetVersionConsumingTask;
import quilt.internal.tasks.diff.UnpickTargetJarTask;
import quilt.internal.tasks.diff.UnpickVersionsMatchConsumingTask;
import quilt.internal.tasks.diff.UnpickVersionsMatchSource;
import quilt.internal.tasks.jarmapping.MapJarTask;
import quilt.internal.tasks.jarmapping.MapPerVersionMappingsJarTask;
import quilt.internal.tasks.mappings.AbstractEnigmaMappingsTask;
import quilt.internal.tasks.mappings.EnigmaMappingsServerTask;
import quilt.internal.tasks.mappings.EnigmaMappingsTask;
import quilt.internal.tasks.setup.DownloadMinecraftLibrariesTask;
import quilt.internal.tasks.unpick.UnpickJarTask;
import quilt.internal.decompile.javadoc.MappingsJavadocProvider;

import static quilt.internal.util.ProviderUtil.toOptional;

/**
 * TODO javadoc, including every configureEach, every configuration
 */
public abstract class QuiltMappingsPlugin implements MappingsProjectPlugin {
    public static final String ENIGMA_RUNTIME_CONFIGURATION_NAME = "enigmaRuntime";

    private static final String ENIGMA_SERVER_PROP_PREFIX = "enigma_server_";
    public static final String ENIGMA_SERVER_PORT_PROP =
        ENIGMA_SERVER_PROP_PREFIX + EnigmaMappingsServerTask.PORT_OPTION;
    public static final String ENIGMA_SERVER_PASSWORD_PROP =
        ENIGMA_SERVER_PROP_PREFIX + EnigmaMappingsServerTask.PASSWORD_OPTION;
    public static final String ENIGMA_SERVER_LOG_PROP =
        ENIGMA_SERVER_PROP_PREFIX + EnigmaMappingsServerTask.LOG_OPTION;
    public static final String ENIGMA_SERVER_ARGS_PROP = ENIGMA_SERVER_PROP_PREFIX + "args";

    @Override
    public void apply(@NotNull Project project) {
        final ProviderFactory providers = this.getProviders();
        final ObjectFactory objects = this.getObjects();

        final Directory projectDir = this.getProjectDir();
        final Directory targetsDir = this.getTargetsDir();

        final DirectoryProperty buildDir = this.getBuildDir();
        final Provider<Directory> minecraftDir = this.getMinecraftDir();

        final Configuration enigmaRuntime = project.getConfigurations().create(ENIGMA_RUNTIME_CONFIGURATION_NAME);

        final PluginContainer plugins = project.getPlugins();

        plugins.apply(MappingVerificationPlugin.class);
        plugins.apply(MapIntermediaryPlugin.class);
        plugins.apply(MapMinecraftJarsPlugin.class);

        // configures EnigmaProfileConsumingTasks
        //   (insertAutoGeneratedMappings, mappings, mappingsUnpicked, mappingsServer, mappingsUnpickedServer)
        // configures MappingsDirConsumingTasks (mappings, mappingsUnpicked, mappingsServer, mappingsUnpickedServer)
        final QuiltMappingsExtension ext = plugins.apply(QuiltMappingsBasePlugin.class).getExt();

        final MinecraftJarsPlugin.Tasks minecraftJarsTasks =
            plugins.apply(MinecraftJarsPlugin.class).getTasks();
        final TaskProvider<DownloadMinecraftLibrariesTask> downloadMinecraftLibraries =
            minecraftJarsTasks.downloadMinecraftLibraries();

        final MapMinecraftJarsPlugin.Tasks mapMinecraftJarsTasks =
            plugins.apply(MapMinecraftJarsPlugin.class).getTasks();
        final TaskProvider<MapPerVersionMappingsJarTask> mapPerVersionMappingsJar =
            mapMinecraftJarsTasks.mapPerVersionMappingsJar();

        final MapV2Plugin.Tasks mappingsV2Tasks =
            plugins.apply(MapV2Plugin.class).getTasks();
        final TaskProvider<UnpickJarTask> unpickHashedJar =
            mappingsV2Tasks.unpickHashedJar();

        final ProcessMappingsPlugin.Tasks processMappingsTasks =
            plugins.apply(ProcessMappingsPlugin.class).getTasks();
        final var decompileVineflower =
            processMappingsTasks.decompileVineflower();

        // register this plugin's tasks
        final TaskContainer tasks = project.getTasks();

        tasks.withType(AbstractEnigmaMappingsTask.class).configureEach(task -> {
            task.classpath(enigmaRuntime);

            task.jvmArgs("-Xmx2048m");
        });

        tasks.register(
            EnigmaMappingsTask.MAPPINGS_TASK_NAME,
            EnigmaMappingsTask.class,
            task -> {
                task.getJarToMap().convention(
                    mapPerVersionMappingsJar.flatMap(MapPerVersionMappingsJarTask::getOutputJar)
                );
            }
        );

        tasks.register(
            EnigmaMappingsTask.MAPPINGS_UNPICKED_TASK_NAME,
            EnigmaMappingsTask.class,
            task -> {
                task.getJarToMap().convention(unpickHashedJar.flatMap(UnpickJarTask::getOutputFile));
            }
        );

        tasks.withType(EnigmaMappingsServerTask.class).configureEach(task -> {
            task.getPort().convention(
                providers.gradleProperty(ENIGMA_SERVER_PORT_PROP)
            );

            task.getPassword().convention(
                providers.gradleProperty(ENIGMA_SERVER_PASSWORD_PROP)
            );

            task.getLog().convention(
                providers.gradleProperty(ENIGMA_SERVER_LOG_PROP)
                    .map(projectDir::file)
                    .orElse(buildDir.file("logs/server.log"))
            );

            toOptional(
                providers.gradleProperty(ENIGMA_SERVER_ARGS_PROP).map(args -> args.split(" "))
            ).ifPresent(task::args);
        });

        tasks.register(
            EnigmaMappingsServerTask.MAPPINGS_SERVER_TASK_NAME,
            EnigmaMappingsServerTask.class,
            task -> {
                task.getJarToMap().convention(mapPerVersionMappingsJar.flatMap(MapJarTask::getOutputJar));
            }
        );

        tasks.register(
            EnigmaMappingsServerTask.MAPPINGS_UNPICKED_SERVER_TASK_NAME,
            EnigmaMappingsServerTask.class,
            task -> {
                task.getJarToMap().convention(unpickHashedJar.flatMap(UnpickJarTask::getOutputFile));
            }
        );

        {
            final var downloadTargetMetaFile = tasks.register(
                DownloadTargetMetaFileTask.DOWNLOAD_TARGET_META_FILE_TASK_NAME,
                DownloadTargetMetaFileTask.class,
                task -> {
                    task.getDest().convention(minecraftDir.map(dir ->
                        dir.file(QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + Constants.MINECRAFT_VERSION + ".json")
                    ));
                }
            );

            // put mapped provider in a property so all tasks use the same cached value
            final Provider<String> targetVersion = objects.property(String.class).convention(
                downloadTargetMetaFile.flatMap(DownloadTargetMetaFileTask::provideTargetVersion)
            );

            tasks.withType(TargetVersionConsumingTask.class).configureEach(task -> {
                task.getTargetVersion().convention(targetVersion);

                task.onlyIf(unused -> task.getTargetVersion().isPresent());
            });
        }

        final var downloadTargetMappingsJar = tasks.register(
            DownloadTargetMappingJarTask.DOWNLOAD_TARGET_MAPPINGS_JAR_TASK_NAME,
            DownloadTargetMappingJarTask.class,
            task -> {
                task.getTargetUnpickConstantsFile().convention(task.provideVersionedFile(
                    targetsDir,
                    version -> QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + version + "-constants.jar"
                ));

                task.getTargetJar().convention(task.provideVersionedFile(
                    targetsDir,
                    version -> QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + version + "-v2.jar"
                ));
            }
        );

        final var extractTargetMappingsJar = tasks.register(
            ExtractTargetMappingJarTask.EXTRACT_TARGET_MAPPINGS_JAR_TASK_NAME,
            ExtractTargetMappingJarTask.class,
            task -> {
                task.getZippedFile().convention(
                    downloadTargetMappingsJar.flatMap(DownloadTargetMappingJarTask::getTargetJar)
                );

                task.getExtractionDest().convention(task.provideVersionedDir(
                    targetsDir,
                    version -> QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + version
                ));
            }
        );

        final Provider<Boolean> unpickVersionsMatch = providers.of(
            UnpickVersionsMatchSource.class,
            spec -> spec.parameters(params -> {
                params.getUnpickVersion().convention(ext.getUnpickVersion());

                params.getUnpickMeta().convention(
                    extractTargetMappingsJar.flatMap(ExtractTargetMappingJarTask::getExtractionDest)
                        .map(dest -> dest.file(MappingsV2JarTask.JAR_UNPICK_META_PATH))
                );
            })
        );

        tasks.withType(UnpickVersionsMatchConsumingTask.class).configureEach(task -> {
            task.getUnpickVersionsMatch().convention(unpickVersionsMatch);

            task.onlyIf(unused -> task.getUnpickVersionsMatch().get());
        });

        final var remapTargetUnpickDefinitions = tasks.register(
            RemapTargetUnpickDefinitionsTask.REMAP_TARGET_UNPICK_DEFINITIONS_TASK_NAME,
            RemapTargetUnpickDefinitionsTask.class,
            task -> {
                task.getInput().convention(
                    extractTargetMappingsJar.flatMap(ExtractTargetMappingJarTask::getExtractionDest)
                        .map(dest -> dest.file(MappingsV2JarTask.JAR_UNPICK_DEFINITION_PATH))
                );

                task.getMappings().convention(
                    extractTargetMappingsJar.flatMap(ExtractTargetMappingJarTask::getExtractionDest)
                        .map(dest -> dest.file(MappingsV2JarTask.JAR_MAPPINGS_PATH))
                );

                task.getOutput().convention(task.provideVersionedFile(
                    targetsDir,
                    version -> QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + version + "remapped-unpick.unpick"
                ));
            }
        );

        final var unpickTargetJar = tasks.register(
            UnpickTargetJarTask.UNPICK_TARGET_JAR_TASK_NAME,
            UnpickTargetJarTask.class,
            task -> {
                task.getUnpickDefinition().convention(
                    remapTargetUnpickDefinitions.flatMap(RemapTargetUnpickDefinitionsTask::getOutput)
                );

                task.getUnpickConstantsJar().convention(
                    downloadTargetMappingsJar.flatMap(DownloadTargetMappingJarTask::getTargetUnpickConstantsFile)
                );

                task.getOutputFile().convention(task.provideVersionedFile(
                    targetsDir,
                    version -> QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + version + "-unpicked.jar"
                ));
            }
        );

        final var remapTargetMinecraftJar = tasks.register(
            RemapTargetMinecraftJarTask.REMAP_TARGET_MINECRAFT_JAR_TASK_NAME,
            RemapTargetMinecraftJarTask.class,
            task -> {
                task.getInputJar().convention(unpickTargetJar.flatMap(UnpickTargetJarTask::getOutputFile));

                task.getMappingsFile().convention(
                    extractTargetMappingsJar.flatMap(ExtractTargetMappingJarTask::getExtractionDest)
                        .map(dest -> dest.dir("mappings").file("mappings.tiny"))
                );

                task.getOutputJar().convention(task.provideVersionedFile(
                    targetsDir,
                    version -> QuiltMappingsBasePlugin.MAPPINGS_NAME_PREFIX + version + "-named.jar"
                ));
            }
        );

        final var decompileTargetVineflower = tasks.register(
            DecompileTargetVineflowerTask.DECOMPILE_TARGET_VINEFLOWER_TASK_NAME,
            DecompileTargetVineflowerTask.class,
            task -> {
                task.getSources().from(remapTargetMinecraftJar.flatMap(RemapTargetMinecraftJarTask::getOutputJar));

                task.getLibraries().from(
                    downloadMinecraftLibraries.flatMap(DownloadMinecraftLibrariesTask::getLibrariesDir)
                );

                task.getDefaultJavadocSource().convention(MappingsJavadocProvider.provideNamed(
                    extractTargetMappingsJar.flatMap(ExtractTargetMappingJarTask::getExtractionDest)
                        .map(dest -> dest.dir("mappings").file("mappings.tiny"))
                ));

                // TODO move this to build/ once generate-diff.yml uses generateDiff
                task.getOutput().convention(projectDir.dir("namedTargetSrc"));
            }
        );

        // TODO use this in generate-diff.yml
        tasks.register(
            DiffDirectoriesTask.GENERATE_DIFF_TASK_NAME,
            DiffDirectoriesTask.class,
            task -> {
                task.getAdditionalArgs().add("-bur");

                task.getFirst().convention(decompileTargetVineflower.flatMap(DecompileTargetVineflowerTask::getOutput));

                task.getSecond().convention(decompileVineflower.flatMap(DecompileVineflowerTask::getOutput));

                task.getDest().convention(buildDir.file("target.diff"));
            }
        );
    }
}
